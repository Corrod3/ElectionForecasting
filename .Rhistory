split = " | ", fixed = TRUE),
function(x) x[[2]])
DaliaDE$ranking3 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[3]])
DaliaDE$ranking4 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[4]])
DaliaDE$ranking5 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[5]])
DaliaDE$ranking6 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[6]])
# most preferred party (consistency check with vote for next election/identify divergencies?)
ggplot(DaliaDE, aes(x=ranking1)) +
geom_bar() + # bar type
coord_flip() # flip sides
# How voters 1 to 2nd preferences are related
# plot function for flow chart
source("transitionplot.R")
# generate data frame relating rank1 to rank2 for transtion pot
SecPref <- as.data.frame(table(rank1 = DaliaDE$ranking1,
rank2 = DaliaDE$ranking2))
SecPref <- spread(SecPref, rank2, Freq)
# transition plot (see transistion plot script for example)
transitionPlot(as.matrix(SecPref[,-1]),
box_txt = as.character(SecPref[,1]))
# voter loyality ##############################################################
# idea: compare past self-reported voting with intended voting?!
# (how about non-voters / too young voters)
VoteLast <- as.data.frame(table(
last.vote = DaliaDE$voted_party_last_election_de,
next.vote = DaliaDE$vote_nextelection_de))
VoteLast <- spread(VoteLast, next.vote, Freq)
# remove non-voters from last election (not relevant for loyality consideration)
VoteLast <- VoteLast %>%
filter(last.vote != "Not able" &
last.vote != "Other" &
last.vote != "No vote")
# clean table
rownames(VoteLast) <- VoteLast$last.vote
VoteLast <- select(VoteLast, c(2:ncol(VoteLast)))
PartyOrder <- c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD")
VoteLast <- VoteLast[PartyOrder,]
VoteLast <- VoteLast[,PartyOrder]
###############################################################################
## Election Forecasting
## by: Alexander Sacharow & Moritz Hemmerlein
###############################################################################
###############################################################################
# CONTENT
# 0. Preparation
# 1. Get data
# 2. Data mining
# 3. Estimates
###############################################################################
###############################################################################
# To-Do / Discussion
# 1. Cleaning sample
#      a. Non-voters
#      b. non-citizen
#      c. too young (17 or 18?)
#      d. not able
# 2. What to do with votes who claim that they definitely don't vote?
# 3. Ideas for estimation and actual forecast?
# 4. Account for potential anti-incumbent bias, late swing,
#     differential turnout bias, "don't knowers" bias and vote intention misreporting
# 5. How close is this survey to Forsa etc...?
# 6. Attach value labels to coded data
###############################################################################
###############################################################################
# 0. Preparations
###############################################################################
# Clear Global environment
rm(list=ls())
## Setting Working directory
try(setwd("D:/Eigene Datein/Dokumente/Uni/Hertie/Materials/Election Forecasting/ElectionForecasting"), silent = TRUE)
try(setwd("C:\\Users\\Moritz\\Desktop\\ElectionForecasting"), silent = TRUE)
# Collect packages/libraries we need:
packages <- c("readxl", "dplyr", "ggplot2", "tidyr" ,"reshape2", "scales")
# package and why it is needed
# readxl: import excel files
# dyplyr: data manipulation
# ggplot: plots (e.g. density)
# tidyr: spread function
# reshape2: melt function
# scales: label transformation in ggplot
# install packages if not installed before
for (p in packages) {
if (p %in% installed.packages()[,1]) {
require(p, character.only=T)
}
else {
install.packages(p, repos="http://cran.rstudio.com", dependencies = TRUE)
require(p, character.only=T)
}
}
rm(p, packages)
###############################################################################
# 1. get data
###############################################################################
# Import Dalia data coded
DaliaC <- read.csv("Raw\\coded_csv\\data_coded_e28.csv - data_coded_e28.csv")
# change data type to character and factor
DaliaC[1] <- as.character(unlist(DaliaC[1]))
for(i in 5:ncol(DaliaC)) {
DaliaC[i] <- as.factor(unlist(DaliaC[i]))
}
# rename columns to remove prefix (using regex)
names(DaliaC) <- sub(".*\\.\\.(.+)", "\\1", names(DaliaC))
# types for excel import
types <- replicate(90, "text")
types[2] <- "numeric"
types[4] <- "numeric"
#Import dalia data as strings
DaliaS <- read_excel("Raw/Dalia_research_challenge_europulse.xlsx",sheet=1,
col_types=types, na="NA")
# change types
DaliaS[3] <- as.factor(unlist(DaliaS[3]))
for(i in 5:ncol(DaliaS)) {
DaliaS[i] <- as.factor(unlist(DaliaS[i]))
}
# change column names
names(DaliaS) <- sub("\\[.+\\] (.+)", "\\1", names(DaliaS))
# dataset with german users/sorting
DaliaDE <- DaliaS %>% filter(country_code == "DE") %>% arrange(age,uuid)
# Factor variables can only be accessed through labels not underlying levels
# Option: Package lfactors
# Create easy identifier
DaliaDE$Identifier <- c(1:nrow(DaliaDE))
DaliaDE <- DaliaDE %>% select(Identifier, everything()) %>%
select(c(1,3:ncol(DaliaDE))) # Drops uuid
# Rename label
parties <- c("AfD", "Gruenen", "Union", "Linke", "FDP", "No vote", "Other", "SPD")
levels(DaliaDE$vote_nextelection_de) <- parties
#change values
# DaliaDE$vote_nextelection_de <- plyr::mapvalues(DaliaDE$vote_nextelection_de,
#           from = c("AfD â Alternative fur Deutschland", "BÃ¼ndnis 90 / Die GrÃ¼nen",
#                    "CDU/CSU â Christlich Demokratische Union/Christlich Soziale Union",
#                    "Die Linke", "FDP - Freie Demokratische Partei",
#                    "SPD â Sozialdemokratische Partei Deutschlands", "Other",
#                    "I would not vote"),
#           to = c("AfD", "Gruenen", "Union", "Linke", "FDP", "SPD",
#                  "Other", "No vote"))
# #for the ones where it dit not work
# levels(DaliaDE$vote_nextelection_de) <- sub("AfD.*", "AfD", levels(DaliaDE$vote_nextelection_de))
# levels(DaliaDE$vote_nextelection_de) <- sub("CDU.*", "CDU", levels(DaliaDE$vote_nextelection_de))
# levels(DaliaDE$vote_nextelection_de) <- sub("SPD.*", "SPD", levels(DaliaDE$vote_nextelection_de))
# Grünen noch umbenennen
label_temp <- c("Not able", "No vote", "Other" ,"AfD", "Gruenen", "Union",
"Linke", "FDP", "SPD")
levels(DaliaDE$voted_party_last_election_de) <- label_temp
rm(label_temp)
# DaliaDE$voted_party_last_election_de <- plyr::mapvalues(DaliaDE$voted_party_last_election_de,
#      from = c("I wanted to vote but I wasn't able to",
#               "No, I did not vote",
#               "Yes, but I voted for another party",
#               "Yes, I voted for AfD â Alternative fÃ¼r Deutschland",
#               "Yes, I voted for BÃ¼ndnis 90 / Die GrÃ¼nen",
#               "Yes, I voted for CDU/CSU â Christlich Demokratische Union/Christlich Soziale Union",
#               "Yes, I voted for Die Linke", "Yes, I voted for FDP - Freie Demokratische Partei",
#               "Yes, I voted for SPD â Sozialdemokratische Partei Deutschlands"),
#      to = c("Not able", "No vote", "Other" ,"AfD", "Gruenen", "Union",
#             "Linke", "FDP", "SPD"))
# # correct the errors
# levels(DaliaDE$voted_party_last_election_de) <- sub(".*AfD.*", "AfD", levels(DaliaDE$voted_party_last_election_de))
# levels(DaliaDE$voted_party_last_election_de) <- sub(".*CDU.*", "CDU", levels(DaliaDE$voted_party_last_election_de))
# levels(DaliaDE$voted_party_last_election_de) <- sub(".*SPD.*", "SPD", levels(DaliaDE$voted_party_last_election_de))
###############################################################################
# 2. data mining
###############################################################################
# vote participation intention (turnout prediction?)
ggplot(DaliaDE, aes(x=vote_next_national_election)) +
geom_bar(aes(y = (..count..)/sum(..count..))) + # bar type
scale_y_continuous(labels=percent) +
ylab("Percentage of total respondents") +
xlab("Voting behavior")
plot(DaliaDE$residency)
# filter people who are not eligble to vote
# 17 year olds will likely turn 18 by the time of the election
DaliaDE <- filter(DaliaDE,
vote_next_national_election != "I'm not eligible to vote" &
residency == "Yes, as a citizen" &
age > 16)
# last election vote
ggplot(filter(DaliaDE,
voted_party_last_election_de != "No vote" &
voted_party_last_election_de != "Not able"),
aes(x=voted_party_last_election_de)) +
geom_bar(aes(y = (..count..)/sum(..count..))) + # bar type
coord_flip() + # flip sides
scale_y_continuous(labels=scales::percent) + # percentages on y axis
ylab("Share of total voters") +
xlab("Parties") +
theme_bw()
# vote intention next election (BT 2017)
ggplot(filter(DaliaDE,vote_nextelection_de != "I would not vote" ),
aes(x=vote_nextelection_de)) +
geom_bar(aes(y = (..count..)/sum(..count..))) + # bar type
coord_flip() + # flip sides
scale_y_continuous(labels=scales::percent) + # percentages on y axis
ylab("Share of total voters") +
xlab("Parties")
# Party ranking ################################################################
# comment to Dalia: Include in ranking: I prefer not to vote
#                   -> allows to capture non-voters
# split ranking
# test with one string
# strsplit("Die Linke | BÃ¼ndnis 90 / Die GrÃ¼nen | SPD â Sozialdemokratische Partei Deutschlands | FDP - Freie Demokratische Partei | CDU/CSU â Christlich Demokratische Union/Christlich Soziale Union | AfD â Alternative fÃ¼r Deutschland"
#          , split = " | ", fixed = TRUE)
# list of all splitted strings
DaliaDE$ranking1 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[1]])
DaliaDE$ranking2 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[2]])
DaliaDE$ranking3 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[3]])
DaliaDE$ranking4 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[4]])
DaliaDE$ranking5 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[5]])
DaliaDE$ranking6 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[6]])
# most preferred party (consistency check with vote for next election/identify divergencies?)
ggplot(DaliaDE, aes(x=ranking1)) +
geom_bar() + # bar type
coord_flip() # flip sides
# How voters 1 to 2nd preferences are related
# plot function for flow chart
source("transitionplot.R")
# generate data frame relating rank1 to rank2 for transtion pot
SecPref <- as.data.frame(table(rank1 = DaliaDE$ranking1,
rank2 = DaliaDE$ranking2))
SecPref <- spread(SecPref, rank2, Freq)
# transition plot (see transistion plot script for example)
transitionPlot(as.matrix(SecPref[,-1]),
box_txt = as.character(SecPref[,1]))
# voter loyality ##############################################################
# idea: compare past self-reported voting with intended voting?!
# (how about non-voters / too young voters)
VoteLast <- as.data.frame(table(
last.vote = DaliaDE$voted_party_last_election_de,
next.vote = DaliaDE$vote_nextelection_de))
VoteLast <- spread(VoteLast, next.vote, Freq)
# remove non-voters from last election (not relevant for loyality consideration)
VoteLast <- VoteLast %>%
filter(last.vote != "Not able" &
last.vote != "Other" &
last.vote != "No vote")
# clean table
rownames(VoteLast) <- VoteLast$last.vote
VoteLast <- select(VoteLast, c(2:ncol(VoteLast)))
VoteLast <- VoteLast[c(PartyOrder, "No Vote", "Other"),]
VoteLast <- VoteLast[c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD", "No Vote", "Other"),]
VoteLast <- VoteLast[,c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD")]
###############################################################################
## Election Forecasting
## by: Alexander Sacharow & Moritz Hemmerlein
###############################################################################
###############################################################################
# CONTENT
# 0. Preparation
# 1. Get data
# 2. Data mining
# 3. Estimates
###############################################################################
###############################################################################
# To-Do / Discussion
# 1. Cleaning sample
#      a. Non-voters
#      b. non-citizen
#      c. too young (17 or 18?)
#      d. not able
# 2. What to do with votes who claim that they definitely don't vote?
# 3. Ideas for estimation and actual forecast?
# 4. Account for potential anti-incumbent bias, late swing,
#     differential turnout bias, "don't knowers" bias and vote intention misreporting
# 5. How close is this survey to Forsa etc...?
# 6. Attach value labels to coded data
###############################################################################
###############################################################################
# 0. Preparations
###############################################################################
# Clear Global environment
rm(list=ls())
## Setting Working directory
try(setwd("D:/Eigene Datein/Dokumente/Uni/Hertie/Materials/Election Forecasting/ElectionForecasting"), silent = TRUE)
try(setwd("C:\\Users\\Moritz\\Desktop\\ElectionForecasting"), silent = TRUE)
# Collect packages/libraries we need:
packages <- c("readxl", "dplyr", "ggplot2", "tidyr" ,"reshape2", "scales")
# package and why it is needed
# readxl: import excel files
# dyplyr: data manipulation
# ggplot: plots (e.g. density)
# tidyr: spread function
# reshape2: melt function
# scales: label transformation in ggplot
# install packages if not installed before
for (p in packages) {
if (p %in% installed.packages()[,1]) {
require(p, character.only=T)
}
else {
install.packages(p, repos="http://cran.rstudio.com", dependencies = TRUE)
require(p, character.only=T)
}
}
rm(p, packages)
###############################################################################
# 1. get data
###############################################################################
# Import Dalia data coded
DaliaC <- read.csv("Raw\\coded_csv\\data_coded_e28.csv - data_coded_e28.csv")
# change data type to character and factor
DaliaC[1] <- as.character(unlist(DaliaC[1]))
for(i in 5:ncol(DaliaC)) {
DaliaC[i] <- as.factor(unlist(DaliaC[i]))
}
# rename columns to remove prefix (using regex)
names(DaliaC) <- sub(".*\\.\\.(.+)", "\\1", names(DaliaC))
# types for excel import
types <- replicate(90, "text")
types[2] <- "numeric"
types[4] <- "numeric"
#Import dalia data as strings
DaliaS <- read_excel("Raw/Dalia_research_challenge_europulse.xlsx",sheet=1,
col_types=types, na="NA")
# change types
DaliaS[3] <- as.factor(unlist(DaliaS[3]))
for(i in 5:ncol(DaliaS)) {
DaliaS[i] <- as.factor(unlist(DaliaS[i]))
}
# change column names
names(DaliaS) <- sub("\\[.+\\] (.+)", "\\1", names(DaliaS))
# dataset with german users/sorting
DaliaDE <- DaliaS %>% filter(country_code == "DE") %>% arrange(age,uuid)
# Factor variables can only be accessed through labels not underlying levels
# Option: Package lfactors
# Create easy identifier
DaliaDE$Identifier <- c(1:nrow(DaliaDE))
DaliaDE <- DaliaDE %>% select(Identifier, everything()) %>%
select(c(1,3:ncol(DaliaDE))) # Drops uuid
# Rename label
parties <- c("AfD", "Gruenen", "Union", "Linke", "FDP", "No vote", "Other", "SPD")
levels(DaliaDE$vote_nextelection_de) <- parties
#change values
# DaliaDE$vote_nextelection_de <- plyr::mapvalues(DaliaDE$vote_nextelection_de,
#           from = c("AfD â Alternative fur Deutschland", "BÃ¼ndnis 90 / Die GrÃ¼nen",
#                    "CDU/CSU â Christlich Demokratische Union/Christlich Soziale Union",
#                    "Die Linke", "FDP - Freie Demokratische Partei",
#                    "SPD â Sozialdemokratische Partei Deutschlands", "Other",
#                    "I would not vote"),
#           to = c("AfD", "Gruenen", "Union", "Linke", "FDP", "SPD",
#                  "Other", "No vote"))
# #for the ones where it dit not work
# levels(DaliaDE$vote_nextelection_de) <- sub("AfD.*", "AfD", levels(DaliaDE$vote_nextelection_de))
# levels(DaliaDE$vote_nextelection_de) <- sub("CDU.*", "CDU", levels(DaliaDE$vote_nextelection_de))
# levels(DaliaDE$vote_nextelection_de) <- sub("SPD.*", "SPD", levels(DaliaDE$vote_nextelection_de))
# Grünen noch umbenennen
label_temp <- c("Not able", "No vote", "Other" ,"AfD", "Gruenen", "Union",
"Linke", "FDP", "SPD")
levels(DaliaDE$voted_party_last_election_de) <- label_temp
rm(label_temp)
# DaliaDE$voted_party_last_election_de <- plyr::mapvalues(DaliaDE$voted_party_last_election_de,
#      from = c("I wanted to vote but I wasn't able to",
#               "No, I did not vote",
#               "Yes, but I voted for another party",
#               "Yes, I voted for AfD â Alternative fÃ¼r Deutschland",
#               "Yes, I voted for BÃ¼ndnis 90 / Die GrÃ¼nen",
#               "Yes, I voted for CDU/CSU â Christlich Demokratische Union/Christlich Soziale Union",
#               "Yes, I voted for Die Linke", "Yes, I voted for FDP - Freie Demokratische Partei",
#               "Yes, I voted for SPD â Sozialdemokratische Partei Deutschlands"),
#      to = c("Not able", "No vote", "Other" ,"AfD", "Gruenen", "Union",
#             "Linke", "FDP", "SPD"))
# # correct the errors
# levels(DaliaDE$voted_party_last_election_de) <- sub(".*AfD.*", "AfD", levels(DaliaDE$voted_party_last_election_de))
# levels(DaliaDE$voted_party_last_election_de) <- sub(".*CDU.*", "CDU", levels(DaliaDE$voted_party_last_election_de))
# levels(DaliaDE$voted_party_last_election_de) <- sub(".*SPD.*", "SPD", levels(DaliaDE$voted_party_last_election_de))
###############################################################################
# 2. data mining
###############################################################################
# vote participation intention (turnout prediction?)
ggplot(DaliaDE, aes(x=vote_next_national_election)) +
geom_bar(aes(y = (..count..)/sum(..count..))) + # bar type
scale_y_continuous(labels=percent) +
ylab("Percentage of total respondents") +
xlab("Voting behavior")
plot(DaliaDE$residency)
# filter people who are not eligble to vote
# 17 year olds will likely turn 18 by the time of the election
DaliaDE <- filter(DaliaDE,
vote_next_national_election != "I'm not eligible to vote" &
residency == "Yes, as a citizen" &
age > 16)
# last election vote
ggplot(filter(DaliaDE,
voted_party_last_election_de != "No vote" &
voted_party_last_election_de != "Not able"),
aes(x=voted_party_last_election_de)) +
geom_bar(aes(y = (..count..)/sum(..count..))) + # bar type
coord_flip() + # flip sides
scale_y_continuous(labels=scales::percent) + # percentages on y axis
ylab("Share of total voters") +
xlab("Parties") +
theme_bw()
# vote intention next election (BT 2017)
ggplot(filter(DaliaDE,vote_nextelection_de != "I would not vote" ),
aes(x=vote_nextelection_de)) +
geom_bar(aes(y = (..count..)/sum(..count..))) + # bar type
coord_flip() + # flip sides
scale_y_continuous(labels=scales::percent) + # percentages on y axis
ylab("Share of total voters") +
xlab("Parties")
# Party ranking ################################################################
# comment to Dalia: Include in ranking: I prefer not to vote
#                   -> allows to capture non-voters
# split ranking
# test with one string
# strsplit("Die Linke | BÃ¼ndnis 90 / Die GrÃ¼nen | SPD â Sozialdemokratische Partei Deutschlands | FDP - Freie Demokratische Partei | CDU/CSU â Christlich Demokratische Union/Christlich Soziale Union | AfD â Alternative fÃ¼r Deutschland"
#          , split = " | ", fixed = TRUE)
# list of all splitted strings
DaliaDE$ranking1 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[1]])
DaliaDE$ranking2 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[2]])
DaliaDE$ranking3 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[3]])
DaliaDE$ranking4 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[4]])
DaliaDE$ranking5 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[5]])
DaliaDE$ranking6 <- sapply(strsplit(as.character(DaliaDE$ranking_party_de),
split = " | ", fixed = TRUE),
function(x) x[[6]])
# most preferred party (consistency check with vote for next election/identify divergencies?)
ggplot(DaliaDE, aes(x=ranking1)) +
geom_bar() + # bar type
coord_flip() # flip sides
# How voters 1 to 2nd preferences are related
# plot function for flow chart
source("transitionplot.R")
# generate data frame relating rank1 to rank2 for transtion pot
SecPref <- as.data.frame(table(rank1 = DaliaDE$ranking1,
rank2 = DaliaDE$ranking2))
SecPref <- spread(SecPref, rank2, Freq)
# transition plot (see transistion plot script for example)
transitionPlot(as.matrix(SecPref[,-1]),
box_txt = as.character(SecPref[,1]))
# voter loyality ##############################################################
# idea: compare past self-reported voting with intended voting?!
# (how about non-voters / too young voters)
VoteLast <- as.data.frame(table(
last.vote = DaliaDE$voted_party_last_election_de,
next.vote = DaliaDE$vote_nextelection_de))
VoteLast <- spread(VoteLast, next.vote, Freq)
# remove non-voters from last election (not relevant for loyality consideration)
VoteLast <- VoteLast %>%
filter(last.vote != "Not able" &
last.vote != "Other" &
last.vote != "No vote")
# clean table
rownames(VoteLast) <- VoteLast$last.vote
VoteLast <- select(VoteLast, c(2:ncol(VoteLast)))
# order rows and columns
VoteLast <- VoteLast[c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD", "No Vote", "Other"),]
VoteLast <- VoteLast[,c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD")]
VoteLast <- as.data.frame(table(
last.vote = DaliaDE$voted_party_last_election_de,
next.vote = DaliaDE$vote_nextelection_de))
VoteLast <- spread(VoteLast, next.vote, Freq)
# remove non-voters from last election (not relevant for loyality consideration)
VoteLast <- VoteLast %>%
filter(last.vote != "Not able" &
last.vote != "Other" &
last.vote != "No vote")
# clean table
rownames(VoteLast) <- VoteLast$last.vote
VoteLast <- select(VoteLast, c(2:ncol(VoteLast)))
VoteLast <- VoteLast[c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD", "No vote", "Other"),]
VoteLast <- as.data.frame(table(
last.vote = DaliaDE$voted_party_last_election_de,
next.vote = DaliaDE$vote_nextelection_de))
VoteLast <- spread(VoteLast, next.vote, Freq)
# remove non-voters from last election (not relevant for loyality consideration)
VoteLast <- VoteLast %>%
filter(last.vote != "Not able" &
last.vote != "Other" &
last.vote != "No vote")
# clean table
rownames(VoteLast) <- VoteLast$last.vote
VoteLast <- select(VoteLast, c(2:ncol(VoteLast)))
VoteLast <- VoteLast[c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD"),]
VoteLast <- VoteLast[,c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD", "No vote", "Other")]
VoteLast$loyality <- diag(as.matrix(VoteLast))/rowSums(VoteLast)
transitionPlot(as.matrix(VoteLast[,c(1:6)]),
box_txt = c("Union", "SPD", "Gruenen", "Linke", "FDP", "AfD"))
ggplot(filter(DaliaDE, vote_nextelection_de != "I would not vote"),
aes(x = vote_nextelection_de, fill = certainty_party_to_vote)) +
geom_bar() +
coord_flip() # flip sides
